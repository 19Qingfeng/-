# 遇到已解决的问题

- TOTP 基于时间的一次性密码算法：根据预共享的密钥与当前时间计算一次性密码的算法。

简单来说，首次登陆成功后在 MFA 中如果开启了 TOTP 的话，此时：

- 用户未绑定 TOTP 方式，那么 Server 端下发对应二维码（二维码中存储对应的用户名和密钥 服务器随机生成一个类似于『DPI45HKISEXU6HG7』的密钥，并且把这个密钥保存在数据库中）。

- 此时，Web 页面上显示一个二维码，内容是一个 URI 地址（otpauth://totp/账号?secret=密钥），如『otpauth://totp/kisexu@gmail.com?secret=DPI45HCEBCJK6HG7』

- 用户使用移动设备（当然也有传统网盾之类，现在适用性不多了）固定 APP 扫码，比如 google authenticator 对于该二维码进行扫码，紧接着 google authenticator 中会读取到当前二维码中的用户名称和密码。(客户端扫描二维码，把密钥『DPI45HKISEXU6HG7』保存在客户端)

- 当用户完成首次登陆认证时，如果开启了 TOTP 验证，此时：

- 客户端每 30 秒使用密钥『DPI45HKISEXU6HG7』和时间戳通过一种『算法』生成一个 6 位数字的一次性密码，如『684060』。

- 用户登陆时需要输入一次性密码『684060』。

- 服务器端使用保存在数据库中的密钥『DPI45HKISEXU6HG7』和时间戳通过同一种『算法』生成一个 6 位数字的一次性密码。懂控制变量法，如果算法相同、密钥相同，又是同一个时间（时间戳相同），那么客户端和服务器计算出的一次性密码是一样的。服务器验证时如果一样，就登录成功了。

> 算法核心大概为 `T = Math.floor((Current Unix time-TO)/X)`

- X 表示步长，意味间隔时间内的密钥应该相同，默认是 30 秒。
- Current Unix time 当前时间戳。
- T0 表示 UTC 时间的起始时间戳，即 1970 年一月一日。
- Math.floor 函数向下取整。
- T 必须是一个大于 32bit 的整型，才能支持到 2038 年以后。例如当 X=30 时，59 对应的 T 为 1，60 对应的 T 为 2。

# 遗留问题

- LDAP 概念，实现方法，原理得看看。

- react-use useAsyncFn 瞅瞅

- 思考一下业务中现在的文档生成，需要手动编写 VuePress md 文件，后续有空了思考下能否在构建时一体化生成对应的文档内容。
